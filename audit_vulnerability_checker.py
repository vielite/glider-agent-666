#!/usr/bin/env python3
"""Check audit report findings against an approved vulnerability list."""

import argparse
import json
import os
import re
import textwrap
import urllib.request

from PyPDF2 import PdfReader


FINDING_HEADER_RE = re.compile(
    r"^(?:finding|issue|observation|vulnerability|risk)\b[\s:.-]*(.*)$",
    re.IGNORECASE,
)


def read_pdf_text(pdf_path: str) -> str:
    reader = PdfReader(pdf_path)
    pages = []
    for page in reader.pages:
        text = page.extract_text() or ""
        pages.append(text)
    return "\n".join(pages)


def parse_findings(text: str) -> list[dict[str, str]]:
    findings = []
    current = None
    for raw_line in text.splitlines():
        line = raw_line.strip()
        if not line:
            if current and current["body"]:
                current["body"].append("")
            continue
        header_match = FINDING_HEADER_RE.match(line)
        if header_match:
            if current:
                findings.append(
                    {
                        "title": current["title"],
                        "body": "\n".join(current["body"]).strip(),
                    }
                )
            title = header_match.group(1).strip() or "Untitled Finding"
            current = {"title": title, "body": []}
            continue
        if current is None:
            current = {"title": "Finding", "body": []}
        current["body"].append(line)
    if current:
        findings.append(
            {"title": current["title"], "body": "\n".join(current["body"]).strip()}
        )
    if len(findings) <= 1:
        paragraphs = [p.strip() for p in text.split("\n\n") if p.strip()]
        findings = [
            {"title": f"Finding {index + 1}", "body": paragraph}
            for index, paragraph in enumerate(paragraphs)
        ]
    return findings


def load_approved_list(path: str) -> list[str]:
    with open(path, "r", encoding="utf-8") as handle:
        entries = [line.strip() for line in handle if line.strip()]
    return entries


def normalize(text: str) -> str:
    return re.sub(r"\s+", " ", text.strip().lower())


def locally_approved(finding: dict[str, str], approved: list[str]) -> bool:
    text = normalize(f"{finding['title']} {finding['body']}")
    return any(normalize(entry) in text for entry in approved)


def call_gemini(api_key: str, finding: dict[str, str], approved: list[str]) -> dict:
    prompt = textwrap.dedent(
        f"""
        You are reviewing an audit finding and comparing it to an approved vulnerability list.
        Approved vulnerabilities (case-insensitive):\n{chr(10).join(approved)}

        Finding title: {finding['title']}
        Finding details:\n{finding['body']}

        Respond with strict JSON only, with keys:
        - approved: true/false if the finding matches the approved list
        - title: concise vulnerability title
        - summary: brief description (1-2 sentences)
        """
    ).strip()

    payload = {
        "contents": [
            {
                "role": "user",
                "parts": [{"text": prompt}],
            }
        ]
    }

    request = urllib.request.Request(
        "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"
        f"?key={api_key}",
        data=json.dumps(payload).encode("utf-8"),
        headers={"Content-Type": "application/json"},
        method="POST",
    )

    with urllib.request.urlopen(request, timeout=30) as response:
        raw = response.read().decode("utf-8")
    data = json.loads(raw)
    text = data["candidates"][0]["content"]["parts"][0]["text"]
    return json.loads(text)


def evaluate_findings(findings: list[dict[str, str]], approved: list[str], api_key: str | None) -> list[dict]:
    unapproved = []
    for finding in findings:
        if locally_approved(finding, approved):
            continue
        if not api_key:
            unapproved.append(
                {
                    "title": finding["title"],
                    "summary": finding["body"].split("\n", 1)[0][:240],
                }
            )
            continue
        result = call_gemini(api_key, finding, approved)
        if not result.get("approved", False):
            unapproved.append(
                {
                    "title": result.get("title") or finding["title"],
                    "summary": result.get("summary") or finding["body"].split("\n", 1)[0][:240],
                }
            )
    return unapproved


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Compare audit PDF findings with an approved vulnerability list."
    )
    parser.add_argument("--pdf", required=True, help="Path to the audit report PDF")
    parser.add_argument(
        "--approved", required=True, help="Path to approved.txt vulnerability list"
    )
    args = parser.parse_args()

    approved = load_approved_list(args.approved)
    report_text = read_pdf_text(args.pdf)
    findings = parse_findings(report_text)
    api_key = os.getenv("GEMINI_API_KEY")
    unapproved = evaluate_findings(findings, approved, api_key)

    if not unapproved:
        print("All findings match approved vulnerabilities.")
        return

    print("Unapproved vulnerabilities found:")
    for item in unapproved:
        print(f"- {item['title']}")
        print(f"  {item['summary']}")


if __name__ == "__main__":
    main()
